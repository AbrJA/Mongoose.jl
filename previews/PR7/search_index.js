var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Mongoose.MgConnection","page":"API","title":"Mongoose.MgConnection","text":"MgConnection\n\nA type alias for a pointer to a Mongoose connection. This is used to represent a connection to a client in the Mongoose server.\n\n\n\n\n\n","category":"type"},{"location":"api/#Mongoose.MgHttpHeader","page":"API","title":"Mongoose.MgHttpHeader","text":"struct MgHttpHeader\n    name::MgStr\n    val::MgStr\nend\n\nA Julia representation of Mongoose's struct mg_http_header, representing a single HTTP header.\n\nFields\n\nname::MgStr: An MgStr structure representing the header field name (e.g., \"Content-Type\").\nval::MgStr: An MgStr structure representing the header field value (e.g., \"application/json\").\n\n\n\n\n\n","category":"type"},{"location":"api/#Mongoose.MgHttpMessage","page":"API","title":"Mongoose.MgHttpMessage","text":"struct MgHttpMessage\n    method::MgStr\n    uri::MgStr\n    query::MgStr\n    proto::MgStr\n    headers::NTuple{MG_MAX_HTTP_HEADERS, MgHttpHeader}\n    body::MgStr\n    message::MgStr\nend\n\nA Julia representation of Mongoose's struct mg_http_message, containing parsed information about an HTTP request or response.\n\nFields\n\nmethod::MgStr: The HTTP method (e.g., \"GET\", \"POST\").\nuri::MgStr: The request URI (e.g., \"/api/data\").\nquery::MgStr: The query string part of the URI (e.g., \"id=123\").\nproto::MgStr: The protocol string (e.g., \"HTTP/1.1\").\nheaders::NTuple{MG_MAX_HTTP_HEADERS, MgHttpHeader}: A tuple of MgHttpHeader structs representing the HTTP headers.\nbody::MgStr: The body of the HTTP message.\nmessage::MgStr: The entire raw HTTP message.\n\n\n\n\n\n","category":"type"},{"location":"api/#Mongoose.MgStr","page":"API","title":"Mongoose.MgStr","text":"struct MgStr\n    ptr::Cstring\n    len::Csize_t\nend\n\nA Julia representation of Mongoose's struct mg_str which is a view into a string buffer. It's used to represent strings returned by Mongoose.\n\nFields\n\nptr::Cstring: A pointer to the beginning of the string data in memory.\nlen::Csize_t: The length of the string in bytes.\n\n\n\n\n\n","category":"type"},{"location":"api/#Mongoose.mg_body-Tuple{MgHttpMessage}","page":"API","title":"Mongoose.mg_body","text":"mg_body(message::MgHttpMessage) -> String\n\nExtracts the body of the HTTP message from an MgHttpMessage as a Julia String.\n\nArguments\n\nmessage::MgHttpMessage: The HTTP message object.\n\nReturns\n\nString: The body content of the HTTP message.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mongoose.mg_headers-Tuple{MgHttpMessage}","page":"API","title":"Mongoose.mg_headers","text":"mg_headers(message::MgHttpMessage) -> NamedTuple\n\nExtracts all HTTP headers from an MgHttpMessage into a Julia Named Tuple.\n\nArguments\n\nmessage::MgHttpMessage: The HTTP message object.\n\nReturns\n\nNamedTuple: A dictionary where keys are header names and values are header values.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mongoose.mg_http_reply-Tuple{Ptr{Nothing}, Integer, AbstractString, AbstractString}","page":"API","title":"Mongoose.mg_http_reply","text":"mg_http_reply(conn::MgConnection, status::Integer, headers::AbstractString, body::AbstractString)::Cvoid\n\nSends an HTTP reply to a connected client. It constructs and sends an HTTP response including the status code, headers, and body.\n\nArguments\n\nconn::MgConnection: A pointer to the Mongoose connection to which the reply should be sent.\nstatus::Integer: The HTTP status code (e.g., 200 for OK, 404 for Not Found).\nheaders::AbstractString: A string containing HTTP headers, separated by \\r\\n. For example: \"Content-Type: text/plain\\r\\nCustom-Header: value\\r\\n\".\nbody::AbstractString: The body of the HTTP response.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mongoose.mg_json_reply-Tuple{Ptr{Nothing}, Integer, AbstractString}","page":"API","title":"Mongoose.mg_json_reply","text":"mg_json_reply(conn::MgConnection, status::Integer, body::AbstractString)\n\nThis is a convenience function that calls mg_http_reply with the Content-Type header set to application/json.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mongoose.mg_message-Tuple{MgHttpMessage}","page":"API","title":"Mongoose.mg_message","text":"mg_message(message::MgHttpMessage) -> String\n\nExtracts the entire raw HTTP message from an MgHttpMessage as a Julia String.\n\nArguments\n\nmessage::MgHttpMessage: The HTTP message object.\n\nReturns\n\nString: The complete raw HTTP message string.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mongoose.mg_method-Tuple{MgHttpMessage}","page":"API","title":"Mongoose.mg_method","text":"mg_method(message::MgHttpMessage) -> String\n\nExtracts the HTTP method from an MgHttpMessage as a Julia String.\n\nArguments\n\nmessage::MgHttpMessage: The HTTP message object.\n\nReturns\n\nString: The HTTP method (e.g., \"GET\", \"POST\").\n\n\n\n\n\n","category":"method"},{"location":"api/#Mongoose.mg_proto-Tuple{MgHttpMessage}","page":"API","title":"Mongoose.mg_proto","text":"mg_proto(message::MgHttpMessage) -> String\n\nExtracts the protocol string from an MgHttpMessage as a Julia String.\n\nArguments\n\nmessage::MgHttpMessage: The HTTP message object.\n\nReturns\n\nString: The protocol string (e.g., \"HTTP/1.1\").\n\n\n\n\n\n","category":"method"},{"location":"api/#Mongoose.mg_query-Tuple{MgHttpMessage}","page":"API","title":"Mongoose.mg_query","text":"mg_query(message::MgHttpMessage) -> String\n\nExtracts the query string from an MgHttpMessage as a Julia String.\n\nArguments\n\nmessage::MgHttpMessage: The HTTP message object.\n\nReturns\n\nString: The query string (e.g., \"param=value&id=1\").\n\n\n\n\n\n","category":"method"},{"location":"api/#Mongoose.mg_register!-Tuple{AbstractString, AbstractString, Function}","page":"API","title":"Mongoose.mg_register!","text":"mg_register!(method::Symbol, uri::AbstractString, handler::Function)\n\nRegisters an HTTP request handler for a specific method and URI.\n\nArguments\n\nmethod::AbstractString: The HTTP method (e.g., GET, POST, PUT, PATCH, DELETE).\nuri::AbstractString: The URI path to register the handler for (e.g., \"/api/users\").\nhandler::Function: The Julia function to be called when a matching request arrives.\n\nThis function should accept a MgConnection pointer as its first argument, followed by any additional keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mongoose.mg_serve!-Tuple{}","page":"API","title":"Mongoose.mg_serve!","text":"mg_serve!(host::AbstractString=\"127.0.0.1\", port::Integer=8080)::Nothing\n\nStarts the Mongoose HTTP server. Initialize the Mongoose manager, binds an HTTP listener, and starts a background Task to poll the Mongoose event loop.\n\nArguments\n\nhost::AbstractString=\"127.0.0.1\": The IP address or hostname to listen on. Defaults to \"127.0.0.1\" (localhost).\nport::Integer=8080: The port number to listen on. Defaults to 8080.\nasync::Bool=true: If true, runs the server in a non-blocking mode. If false, blocks until the server is stopped.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mongoose.mg_shutdown!-Tuple{}","page":"API","title":"Mongoose.mg_shutdown!","text":"mg_shutdown!()::Nothing\n\nStops the running Mongoose HTTP server. Sets a flag to stop the background event loop task, and then frees the Mongoose associated resources.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mongoose.mg_text_reply-Tuple{Ptr{Nothing}, Integer, AbstractString}","page":"API","title":"Mongoose.mg_text_reply","text":"mg_text_reply(conn::MgConnection, status::Integer, body::AbstractString)\n\nThis is a convenience function that calls mg_http_reply with the Content-Type header set to text/plain.\n\n\n\n\n\n","category":"method"},{"location":"api/#Mongoose.mg_uri-Tuple{MgHttpMessage}","page":"API","title":"Mongoose.mg_uri","text":"mg_uri(message::MgHttpMessage) -> String\n\nExtracts the URI from an MgHttpMessage as a Julia String.\n\nArguments\n\nmessage::MgHttpMessage: The HTTP message object.\n\nReturns\n\nString: The request URI (e.g., \"/api/users\").\n\n\n\n\n\n","category":"method"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Basic-Setup","page":"Examples","title":"Basic Setup","text":"First, load the package:\n\nusing Mongoose","category":"section"},{"location":"examples/#GET-Endpoint-with-Query-Parameters","page":"Examples","title":"GET Endpoint with Query Parameters","text":"This example demonstrates how to parse query parameters from the request URI.\n\nusing Mongoose\n\nserver = SyncServer()\n\nstruct Person\n    name::String\nend\n\nfunction greet(req::Request, params::Dict{String,String})\n    person = try\n        deserialize(Person, req.query)\n    catch e\n        return Response(400, Dict(\"Content-Type\" => \"text/plain\"), \"Invalid query parameters\")\n    end\n    return Response(200, Dict(\"Content-Type\" => \"text/plain\"), \"Hi $(person.name)\")\nend\n\nroute!(server, :get, \"/greet\", greet)\n\n# Start server on port 8080\nstart!(server, port=8080)","category":"section"},{"location":"examples/#POST-Endpoint-with-JSON-Body","page":"Examples","title":"POST Endpoint with JSON Body","text":"This example shows how to handle a POST request and parse a JSON body.\n\nusing Mongoose\nusing JSON\n\nserver = SyncServer()\n\nfunction saygoodbye(req::Request, params::Dict{String,String})\n    try\n        data = JSON.parse(req.body)\n        name = get(data, \"name\", \"Friend\")\n\n        response_data = Dict(\"message\" => \"Goodbye, $name!\")\n        return Response(200, Dict(\"Content-Type\" => \"application/json\"), JSON.json(response_data))\n    catch e\n        return Response(400, Dict(\"Content-Type\" => \"text/plain\"), \"Invalid JSON\")\n    end\nend\n\nroute!(server, :post, \"/saygoodbye\", saygoodbye)\n\nstart!(server, port=8081)","category":"section"},{"location":"examples/#Async-Server-with-Multithreading","page":"Examples","title":"Async Server with Multithreading","text":"For higher performance, use AsyncServer and start Julia with multiple threads (julia -t 4).\n\nusing Mongoose\n\n# Create an async server with 4 worker threads\nserver = AsyncServer(nworkers=4)\n\nfunction heavy_task(req::Request, params::Dict{String,String})\n    # Simulate work\n    s = sum(rand(1000000))\n    return Response(200, Dict(\"Content-Type\" => \"text/plain\"), \"Computed: $s\")\nend\n\nroute!(server, :get, \"/compute\", heavy_task)\n\n# Start non-blocking\nstart!(server, port=8082, blocking=false)\n\n# Do other things...\n\n# Shutdown when done\nshutdown!(server)","category":"section"},{"location":"examples/#Path-Parameters","page":"Examples","title":"Path Parameters","text":"Mongoose.jl supports dynamic path parameters.\n\nusing Mongoose\n\nserver = SyncServer()\n\nfunction get_user(req::Request, params::Dict{String,String})\n    user_id = params[\"id\"]\n    return Response(200, Dict(\"Content-Type\" => \"text/plain\"), \"User ID: $user_id\")\nend\n\n# Define route with parameter :id\nroute!(server, :get, \"/users/:id\", get_user)\n\nstart!(server, port=8083)","category":"section"},{"location":"#Mongoose.jl","page":"Introduction","title":"Mongoose.jl","text":"Mongoose.jl is a Julia package that provides a lightweight and efficient interface for building HTTP servers and web applications. It leverages the Mongoose C library to deliver fast, embeddable web server capabilities directly from Julia code.","category":"section"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"] add Mongoose","category":"section"},{"location":"#Quick-Start","page":"Introduction","title":"Quick Start","text":"Here is a simple example of how to create a synchronous server and define a basic route.\n\nusing Mongoose\n\n# Create a synchronous server\nserver = SyncServer()\n\n# Define a handler function\nfunction hello_world(req::Request, params::Dict{String,String})\n    return Response(200, Dict(\"Content-Type\" => \"text/plain\"), \"Hello from Mongoose.jl!\")\nend\n\n# Register the route\nroute!(server, :get, \"/hello\", hello_world)\n\n# Start the server\nstart!(server, port=8000)\n\n# When done, shutdown the server\nshutdown!(server)","category":"section"},{"location":"#Core-Concepts","page":"Introduction","title":"Core Concepts","text":"","category":"section"},{"location":"#Server-Types","page":"Introduction","title":"Server Types","text":"SyncServer: Runs the event loop in the main thread. This is a blocking operation, suitable for simple scripts or when you want the server to control the main execution flow.\nAsyncServer: Runs the event loop in a background task. This allows the main thread to continue executing other code, making it ideal for interactive sessions or more complex applications.","category":"section"},{"location":"#Handlers","page":"Introduction","title":"Handlers","text":"Handlers are Julia functions that process incoming requests. They must accept two arguments:\n\nreq::Request: Contains details about the HTTP request (method, URI, headers, body, etc.).\nparams::Dict{String,String}: Contains path parameters captured from the URI.\n\nThe handler must return a Response object.","category":"section"},{"location":"#Examples","page":"Introduction","title":"Examples","text":"More comprehensive examples demonstrating various use cases and features can be found on the Examples page.","category":"section"},{"location":"#API","page":"Introduction","title":"API","text":"The full API documentation, including all functions and types, is available on the API page.","category":"section"},{"location":"#Contributing","page":"Introduction","title":"Contributing","text":"Contributions are welcome! Please see the Contributing page for guidelines.","category":"section"},{"location":"#License","page":"Introduction","title":"License","text":"This package is distributed under the GPL-2 License.","category":"section"}]
}
